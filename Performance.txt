Simple pure C Solution: (on tesla)
==================================
For a single packet (first from 2.5 SNR), 11 iterations to complete

Total Time     : 3661 microsec
node processing: 2222 microsec (60%)
bit estimates  : 441 microsec (12%)
transpose      : 919 microsec (25%)

For 1000 packets:
=================
 3712 msec for 1000 packets.
 1000 Successes out of 1000 packets.
 11274 cumulative iterations, or about 11.3 per packet.
Number of iterations for the first few packets:   11 11 11 12 10 10 10 10 11 11

                        ==================================

Direct C to GPU Solution: (on tesla)
==================================
For a single packet (first from 2.5 SNR), 11 iterations to complete

Total Time      : 2760.8 microsec
node processing : 220.9 microsec (8.00%)
bit estimates   : 113.8 microsec (4.12%)
transpose       : 724.4 microsec (26.24%)
Other???        : 1701.7 microsec (61.64%)

For 1000 packets:
=================
2475.005859 msec to decode 1000 packets.
 1000 Successes out of 1000 inputs.
 11274 cumulative iterations, or about 11.3 per packet.
Number of iterations for the first few packets:   11 11 11 12 10 10 10 10 11 11

                        ==================================

GPU Solution: (on kepler) with transpose in GPU
==================================
For a single packet (first from 2.5 SNR), 11 iterations to complete
Total Time      : 2750.5 microsec
node processing : 434.0 microsec (15.78%)
bit estimates   : 240.8 microsec (8.76%)
transpose       : 1293.6 microsec (47.03%)
Other???        : 782.1 microsec (28.43%)

(on tesla)
Total Time      : 1916.4 microsec
node processing : 272.7 microsec (14.23%)
bit estimates   : 145.9 microsec (7.61%)
transpose       : 1056.1 microsec (55.11%)
Other???        : 441.8 microsec (23.05%)

For 1000 packets:
=================
2152.041260 msec to decode 1000 packets.
 1000 Successes out of 1000 inputs.
 11290 cumulative iterations, or about 11.3 per packet.

(on tesla)
1645.981567 msec to decode 1000 packets.

For 10,000 packets (all on kepler):
NTHREADS = 128
===================
21251.273438 msec to decode 10000 packets.
 10000 Successes out of 10000 inputs.
 112900 cumulative iterations, or about 11.3 per packet.
Number of iterations for the first few packets:   12 10 11 10 10 10 13 10 10 12

For 10,000 packets (all on kepler):
NTHREADS = 16
===================
6 6 2560 1000
20512.851562 msec to decode 10000 packets.
 10000 Successes out of 10000 inputs.
 112900 cumulative iterations, or about 11.3 per packet.
Number of iterations for the first few packets:   12 10 11 10 10 10 13 10 10 12

For 10,000 packets (all on kepler):
NTHREADS = 4
===================
6 6 2560 1000
23885.205078 msec to decode 10000 packets.
 10000 Successes out of 10000 inputs.
 112900 cumulative iterations, or about 11.3 per packet.
Number of iterations for the first few packets:   12 10 11 10 10 10 13 10 10 12

===========================================================
===========================================================
Switched to a new LDPC code:  1024 bit rate 4/5
This is the code David has been using for his evaluation.
        Fewer bits are sent per 1024 information bits,
so the error rate is higher than the preceding tests.
This matches the results appearin the Orange Book.
===========================================================
===========================================================

Using Min_Sum algorithm (which was used in earlier tests)
===========================================================
./RunDecoder
parameters have been read.
numBits = 1408, numChecks = 384
6 18 1408 1000
6395.211914 msec to decode 1000 packets.
 890 Successes out of 1000 inputs.
 42661 cumulative iterations, or about 42.7 per packet.
Number of iterations for the first few packets:   25 11 15 26 12 10 27 28 12 24 11 13 14 16 14 12 106 201 21 17

Using optimal algorithm (tanh) - naive implementation.
=====================================================
./RunDecoder
parameters have been read.
numBits = 1408, numChecks = 384
6 18 1408 1000
5245.614746 msec to decode 1000 packets.
 945 Successes out of 1000 inputs.
 28065 cumulative iterations, or about 28.1 per packet.
Number of iterations for the first few packets:   16 11 12 17 11 8 17 17 11 13 12 13 13 13 12 10 27 28 15 12

=====================================================
Using optimal algorithm (tanh) - slightly better implementation.
        Compute product of tanh terms only once while keeping the tanhVal terms;
        then use  -2 * atanh (product/tanhVal[i]) to update eta.
        This requires checking for tanhVal[i] == 0.
=====================================================
./RunDecoder
parameters have been read.
numBits = 1408, numChecks = 384
6 18 1408 1000
4785.023926 msec to decode 1000 packets.
 942 Successes out of 1000 inputs.
 29676 cumulative iterations, or about 29.7 per packet.
Number of iterations for the first few packets:   16 10 12 16 11 9 21 19 11 16 13 14 15 15 10 12 20 39 16 13

=====================================================
Using optimal algorithm (tanh) - implementation from previous report
ONLY reduced NTHREADS  from 32 to 16.
(note, reducing down to 4 produces similar results).
Significant performance enhancement.
=====================================================
./RunDecoder
parameters have been read.
numBits = 1408, numChecks = 384
6 18 1408 1000
4110.838379 msec to decode 1000 packets.
 942 Successes out of 1000 inputs.
 29676 cumulative iterations, or about 29.7 per packet.
Number of iterations for the first few packets:   16 10 12 16 11 9 21 19 11 16 13 14 15 15 10 12 20 39 16 13

======================================================
Using optimal algorithm (tanh) -
with different method to handle  terms where tanh(...) == 0
(see previous implementation for details about this issue)
Instead counting these 0 terms, I replace each one with
a number very close to 0,  MIN_TANH_MAGNITUDE.
Dr. Perrins concurred that this is reasonable).
        This significantly reduces the number of conditionals,
which is important for GPU performance.
        Also, rather surprsingly, it correctly decodes
a few more packets  (947 :: 942) -- from exactly the same input)
and fewer average iterations.  The number of iterations
for the first 20 packets more closely matches the results
from the naive implementation -- suggesting that my
count the 0's method, was not exactly correct.
======================================================
./RunDecoder
parameters have been read.
numBits = 1408, numChecks = 384
6 18 1408 1000
3921.919678 msec to decode 1000 packets.
 947 Successes out of 1000 inputs.
 27840 cumulative iterations, or about 27.8 per packet.
Number of iterations for the first few packets:   16 11 12 17 11 8 17 17 11 13 12 13 13 13 12 10 27 28 15 12

================
December 18.  Baseline
================

kepler [1]% cd SparseMatrix2D
kepler [2]% ./RunDecoder 1024 4 5 3.0 10000
parameters have been read.
numBits = 1408, numChecks = 384
infoLeng = 1024, numParityBits = 256 (1280), numBits = 1408
maxChecksPerBit = 6 maxBitsPerCheck = 18
ebn0 = 3.000000, sigma = 0.313242
 928 Successes out of 1000 inputs (1485 msec).
 1858 Successes out of 2000 inputs (2945 msec).
 2777 Successes out of 3000 inputs (4418 msec).
 3700 Successes out of 4000 inputs (5932 msec).
 4632 Successes out of 5000 inputs (7403 msec).
 5547 Successes out of 6000 inputs (8942 msec).
 6481 Successes out of 7000 inputs (10407 msec).
 7406 Successes out of 8000 inputs (11904 msec).
 8342 Successes out of 9000 inputs (13372 msec).
 9273 Successes out of 10000 inputs (14854 msec).
14854 msec to decode 10000 packets.
 9273 Successes out of 10000 inputs.
 191189 cumulative iterations, or about 19.1 per packet.
Number of iterations for the first few packets:   26 15 15 15 8 10 16 14 19 61 15 26 13 10 18 12 14 21 49 25


#pragma unroll (6)  Does not appear to improve performance (in bitEstimates or cnpOptimalBlock)

also
using #define loop bound, and inner IF statement does not help performance.
